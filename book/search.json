[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EMSC - Get Going with Python",
    "section": "",
    "text": "This is a template repository for Lecture notes that include a computational component. It builds a website from the notes and includes live-links to source code that will run on binder. This template is pre-configured for courses at Research School of Earth Sciences, but is freely available for adoption elsewhere.\nI use the Quarto publication system which converts simple markdown formatted documents to webpages, pdf and slides. Quarto is designed to develop reusable content and is based around pandoc: you should be able to quickly import and convert content to the quarto version of markdown (especially if you have been using jupyter-book or myst-md - the concepts are very similar).\nTo use this repository, you will need make a fork for yourself and replace this content with your own. You will also need set a few configuration options to match the course metadata. I’m going to explain how this works.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>EMSC e-Course template</span>"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "2  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Basics/Ex1-GettingStartedWithPython.html",
    "href": "Basics/Ex1-GettingStartedWithPython.html",
    "title": "4  Exercise 1 - Getting started with Python",
    "section": "",
    "text": "Python on the web\nThe page you are looking at now is an example of a Jupyter ‘notebook’. This allows us to mix text, code and results, and provides a great format for structuring and keeping track of your thoughts and ideas as you work on a project. This is not the only way to write and run Python programmes, and later in the course we will discuss some alternatives that might be better for large, complex programs - but for many straightfoward data analysis tasks the notebook format is ideal.\nJupyter is built around the concept of ‘cells’. There are two main types of cell: Markdown cells, which are used for writing text, equations that describe the program (you’re reading a Markdown cell now!) and provide instructions to the reader. Code cells, which are used for program code and can be executed within the document itself\nHere’s a code cell:\nprint(\"Welcome to Python !\")\nHere is a pyiodide code cell:\nThis is a Pyodide-enabled code cell in a Quarto HTML document.\nThe grey box contains some Python code, which is editable. If you click in this box, and then press Shift+⏎ (i.e. hold down the Shift key on your keyboard and then hit the return key) the code will be run, and any output is displayed below the grey box.\n# Blank code cell (this line is a comment)\n\n# Replace this comment with your own code\nOnly one cell can run at any time. Two things show that a cell is currently running. First, on the right of the menubar is an open circle, as highlighted here:\nThis changes to a filled circle while code is being executed. Secondly, to the left of each code cell is a cell number, such as\nWhile a cell is being executed, this will change to show an asterisk instead of a number:\nIn [*]:\nThe example above executes so quickly that it is difficult to see these changes. To make it more obvious, we can make the computer ‘sleep’ (do nothing) for 5 seconds before printing a message:\nimport time\n\nprint(\"...zzz....\")\ntime.sleep(5)\nprint(\"I'm awake again now!\")\n➤ Execute the above cell, and notice the two indicators that something is running.\nIf we want to stop the cell without waiting for it to finish naturally (perhaps we’ve realised we made a mistake in the code), we can click on the ‘stop’ button in the toolbar:\nThe execution should finish immediately, and you will see an error message printed to the screen to highlight the fact that the cell didn’t finish ‘normally’.\n➤ Run the above cell again, but this time use the ‘stop’ button to terminate execution.",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Exercise 1 - Getting started with Python</span>"
    ]
  },
  {
    "objectID": "Basics/Ex1-GettingStartedWithPython.html#python-on-the-web",
    "href": "Basics/Ex1-GettingStartedWithPython.html#python-on-the-web",
    "title": "4  Exercise 1 - Getting started with Python",
    "section": "",
    "text": "Please enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\n\nWarning\n\n\n\nTry typing your own message in the next cell, and run it\n\n\n\n\n\n\n\n\n\nJupyter toolbar\n\n\n\n\n\nYou can also run cells by clicking the ‘Run’ button in the toolbar:\n\n\n\n\n\nHowever, it’s good to get into the habit of using Shift+⏎, as it is much more convenient when you’re working on a big project.\n\n\n\n\n\n\n\n\n\n\n\nIn [3]:\n\n\n\n\n\n\n\n\n\n\n\n\n\nMarkdown\nMarkdown is a lightweight markup language that you can use to add formatting elements to plaintext text documents. Markdown cells in notebooks allow you to write and describe your thoughts, code, equations directly in your program, making it more readable.\nYou can also edit markdown cells. If you double-click on this text, it will become editable (and be highlighted in green). Once you’ve made any changes, you can press Shift+⏎ and it will be rendered nicely on the screen. Notice that the highlighting changes back to blue.\n➤ Try adding some text to this cell.\nIt is easy to make text in Markdown italic or bold. You can also: - Make bullet points - Including sub-bullets - Insert mathematical expressions using LaTeX syntax, e.g. \\(y=3 \\sin\\left(\\frac{(n+1)x}{2\\pi}\\right)\\)\nMarkdown also enables nicely-formatted code blocks, for example this Python code:\ndef printHello(message):\n    print(\"Hello! \"+message)\nNote that this code is not executable, because Markdown cells are intended for displaying information rather than performing computations.\n➤ Double-click on this cell to see how the text formatting is achieved. Try changing it!\nIf you want to know more about Markdown, plenty of information can be found online. This site might be one good place to start.\n\n\nAdding and removing cells\nNew cells can be created at any point in the document. First, select the cell by clicking once on it (outside the editable area, if it’s a code cell). It should be highlighted in blue, to indicate that you’ve selected it but are not attempting to edit it. If it’s highlighted in green, press Esc on your keyboard to exit ‘edit’ mode. Now, you can either:\n\nPress A or B to insert a new cell above or below the selected cell, or\nFrom the menu bar, select Insert → Insert Cell Above or Insert → Insert Cell Below as highlighted here\n\n\n\n\nAgain, you will probably find things much easier if you get into the habit of using the keyboard commands. By default, new cells are ‘code’ cells. You can change this using the drop-down menu in the toolbar:\n\n\n\nAlternatively, while the cell is highlighted in blue, you can press M to make it a Markdown cell, and Y to turn it back into a code cell.\n➤ Insert a new Markdown cell below this one, and write something in it.\nAs you work through these practicals, you are encouraged to add cells to record your notes and comments.\nOf course, you can also easily delete cells. To do this, select the cell so that it is highlighted in blue, and either press the X key, or select Edit → Delete Cells from the toolbar. You can select multiple cells by holding down the Shift key.\n➤ Delete the cell you added above this one.\nIt is also possible to cut, copy and paste cells, as you will have done when using many other programs.",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Exercise 1 - Getting started with Python</span>"
    ]
  },
  {
    "objectID": "Basics/Ex1-GettingStartedWithPython.html#first-steps-in-python",
    "href": "Basics/Ex1-GettingStartedWithPython.html#first-steps-in-python",
    "title": "4  Exercise 1 - Getting started with Python",
    "section": "First steps in Python",
    "text": "First steps in Python\nWe’ve already seen a couple of examples of Python code. Now let’s try making something from scratch. One thing we can do is simply use Python like a calculator!\n➤ Try typing simple arithmetic into the code cell below and see what happens. For example, try entering\n3+17\nand then hit Shift+⏎. You can also use the operators *, -, / (for division), and the parentheses (). Finally, ** is used to raise a number to some power, so that \\(3^2\\) is entered as 3**2.\n\n# Try it here!\n\n➤ What happens if you enter two lines of calculations before hitting Shift+⏎? Try something like\n3+17\n5*9\nWhat are you seeing? Looking back at the code examples earlier in this notebook, can you work out how to get it to display both answers?\n\nComments\nIn the code cell above, you may have noticed the line\n# Try it here!\nwhich doesn’t look as though it ought to be valid Python code. This is a ‘comment’ line: the computer ignores the # and anything following it on the same line. Comments should be used to document information that helps people to understand how the code works internally. This may seem like a waste of time - but you (or your colleagues) will be grateful in two years’ time when you find you need to change something! The comment character can also be useful for ‘switching off’ lines of code without deleting them. For example, look at this piece of code:\ndef readDataFile(fp):\n    # This function assumes that fp is\n    # a valid file-like object and that the\n    # file has already been opened for reading\n    header = fp.readline()\n    # print(header)\n    [...]\nThe first three lines of comments provide information recording some of the assumptions the programmer made when writing this function (don’t worry if it doesn’t make sense yet!). The fourth comment line is a piece of code that has been ‘commented out’: we don’t want to routinely print the file header, but it is useful to be able to reinstate this easily in case we encounter problems and need to check what the function has read.\nIn fact, ‘commenting out’ code is so common that Jupyter provides a straightforward way to do it. If you select a block of code and press Ctrl+/ (or on a Mac, ⌘+/), the selected lines will all be changed to begin with # comment characters. Pressing Ctrl+/ again will restore the original version.",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Exercise 1 - Getting started with Python</span>"
    ]
  },
  {
    "objectID": "Basics/Ex2-VariablesAndFunctions.html",
    "href": "Basics/Ex2-VariablesAndFunctions.html",
    "title": "5  Exercise 2 - Variables and functions",
    "section": "",
    "text": "Using variables\nAs you may have noticed from the above example, once we have set the value of a variable, we can use it in calculations. Thus,\nwill perform the calculation \\((3\\times 2) = 6\\), and display the answer on the screen. If we wish, we can choose to assign the result to another variable, e.g.\nNow, z contains the value 4. We can also reassign the value of a variable,\nNotice that x appears on both sides of the equals sign here. This should be read as ‘do the calculation x + y and then store the result in x (over-writing whatever was there before)’. We end up with x containing the value \\(3 + 2 = 5\\).\n➤ Try creating some variables, and using them in simple calculations. Check that the results match what you expect.\n# Try it here!\nIn fact, constructs such as x = x + y are so common that Python has a special shorthand notation for this. We can express the same equation by entering x += y. There are similar versions for other operators: -=, *= and /=.\n➤ Try out these shorthand operators. Is x += 3 the same as 3 += x? Why?\n# Try it here!\nThere is no particular advantage to using these short forms, except convenience and readibility.",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Exercise 2 - Variables and functions</span>"
    ]
  },
  {
    "objectID": "Basics/Ex2-VariablesAndFunctions.html#using-variables",
    "href": "Basics/Ex2-VariablesAndFunctions.html#using-variables",
    "title": "5  Exercise 2 - Variables and functions",
    "section": "",
    "text": "x = 3\ny = 2\nprint(x * y)\n\nx = 3\ny = 2\nz = x*y - y\n\nx = 3\ny = 2\nx = x + y",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Exercise 2 - Variables and functions</span>"
    ]
  },
  {
    "objectID": "Basics/Ex2-VariablesAndFunctions.html#naming-conventions",
    "href": "Basics/Ex2-VariablesAndFunctions.html#naming-conventions",
    "title": "5  Exercise 2 - Variables and functions",
    "section": "Naming Conventions",
    "text": "Naming Conventions\nYou can call your variables anything you like. However, following a few conventions will improve the clarity of your code:\n\nIf your variable name is made up of multiple words, either:\n\nJoin them using underscores (e.g. a_long_variable_name = 17), or\nCapitalize the first letter of each word (e.g. AnotherLongVariableName = 23.6). This is sometimes referred to as ‘camel case’ (since it is lower case with extra humps!).\n\nIt is common to use UPPER CASE for constants that should never need to be changed within the program, e.g. GRAVITATIONAL_ACCELERATION = 9.81.\nTraditionally, variables that contain integers have names beginning with the letters i, j, k, l, m, or n; variables containing real numbers start with any other letter. This comes from early programming languages (especially Fortran) where it was a requirement, and follows a similar convention in mathematics. Nowadays, this convention is often ignored for long variable names. However, if your name only contains one or two characters (e.g. a or ix), it is usual to choose the first letter appropriately. In particular, a bare i, j, k, m or n should only be used for a counting index (more on that later). If you ignore this rule, the program will work fine, but you can expect anyone who has to decipher your code in future to get very, very angry with you.\n\nSome other tips:\n\nIf your code is connected to another document (e.g. you are trying to plot some equation from a paper) then use clearly-related names in both. For example, if your paper has the equation \\(y = \\alpha x +3\\gamma\\), then use the variable names x, y, alpha and gamma in your code. You can even use unicode.\nMake your variable names long enough to be clearly understood, but not too long. At most, you probably want it to be based on two or three words.\nDo not give your variable a name that has a special meaning in Python (e.g. int or sum). Doing so will not always cause problems, but it is a common source of grief. Fortunately, most text editors (including the one that is part of Jupyter) will highlight these ‘reserved words’ in a different colour, so you can avoid using them. For example:\n\nx = 3   # x is in black; I can use it for a variable name.\nsum = 5 # sum is in green: it has a special meaning and would be a bad choice for a variable name\nAbove all, try and develop a consistent style, and name similar quantities in similar ways. For example, the following are individually all reasonable choices for variable names:\nmass_of_helium = 4.003\nneon_mass = 20.180\nmassArgon = 39.948\nmKrypton = 83.798\nmXe = 131.293\nHowever, mixing the different styles within one program is guaranteed to cause you confusion and lead to errors. Pick one format that makes sense to you, and stick with it.\n\nTypes\nAs we have discussed, any variable has a type. We can ask Python to report on the type of a given variable by using the command type(variable_name). For example,\na = 3\ntype(a)\nwill print int (shorthand for ‘integer’), while\na = 3.0\ntype(a)\nwill print float (i.e., floating-point). We will encounter other types in due course.\n\n# Try it here!",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Exercise 2 - Variables and functions</span>"
    ]
  },
  {
    "objectID": "Basics/Ex2-VariablesAndFunctions.html#salary-calculations",
    "href": "Basics/Ex2-VariablesAndFunctions.html#salary-calculations",
    "title": "5  Exercise 2 - Variables and functions",
    "section": "Salary calculations",
    "text": "Salary calculations\nLet’s try doing a realistic calculation. Suppose your annual salary is $87,232, and the annual tax rate is 35%. How much money should be paid into your bank account every two weeks?\n➤ Calculate your fortnightly pay. Remember, break the problem down into individual steps, and create variables for each of the quantities involved! You should find the answer is $2,180.80.\n\n# Try it here!\n\nLet’s do something a bit more complicated. Suppose the tax rate is only 20% on the first $30,000 that you earn, and 35% on the remainder.\n➤ Copy your earlier code and adapt it for this case.\n\n# Try it here!",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Exercise 2 - Variables and functions</span>"
    ]
  },
  {
    "objectID": "Basics/Ex2-VariablesAndFunctions.html#functions",
    "href": "Basics/Ex2-VariablesAndFunctions.html#functions",
    "title": "5  Exercise 2 - Variables and functions",
    "section": "Functions",
    "text": "Functions\nA function provides a convenient way to ‘wrap up’ code to accomplish a particular task. Once a function is written, it can (generally) be used without us needing to know anything about how it works. This is a very powerful concept, and complex programs are often made by chaining many functions together.\nIn general, a function has a well-defined set of inputs (sometimes known as the function’s ‘arguments’) and outputs (sometimes called the ‘return value’). In Python, and most other modern programming languages, a ‘function call’ looks like\noutput1, output2 = function_name(input1, input2, input3)\nWe have already encountered a couple of functions: we have used print() and type(). These are known as ‘built-in functions’, as they are a core piece of the Python programming language. For a full list of built-ins, see this page of the official Python documentation. Other functions can be accessed by ‘importing’ them from ‘modules’ - we will learn more about this shortly.\nIt is easy to write your own functions. This is done by using the def command, and writing something like:\ndef function_name(input1, input2, input3):\n    [code to compute outputs...]\n    return output1,output2\nNote that function_name, input1, output1 etc can be any name you wish to use. In general, a function definition comprises: - The keyword def, followed by - The function name, followed by - An opening parenthesis (, followed by - Zero or more input variables, followed by - A closing parenthesis ), followed by - A colon, :\nThis is all followed by an indented block of code containing zero or more lines of the form - The keyword return, followed by - Zero or more variable names (or valid expressions)\nFor example\ndef addThreeNumbers(first, second, third):\n    return first + second + third\nWe can then ‘call’ this function:\na = 3\nb = 5\nresult = addThreeNumbers(a, b, -1)\nThe variable result should now contain the value 7 (= 3 + 5 - 1).\n➤ Create the addThreeNumbers function and try it out.\n\n# Try it here!\n\nA few things to notice from this example: - When we ‘call’ (use) a function, we can give it both named variables (a and b), and values (-1). - The variable names we pass to the function don’t need to match the variable names used when ‘declaring’ (defining) the function - so we can use a and b instead of first and second. - The return keyword specifies what the function result will be.\nHere’s a slightly more complicated example, which calculates the sign and absolute value of the input (unless it is zero):\ndef signAndValue(x):\n    if x == 0:\n        print(\"Unable to handle zero input\")\n    elif x &gt; 0:\n        return +1, x\n    else:\n        return -1, -x\n    print(\"Hope that helps!\")\n➤ Try creating this function and see how it behaves. Some things to think about: - When is the message “Hope that helps!” printed? Why? - What form does the function result have? What is its type? What about if x=0? - What is the role of if/elif/else?\n\n# Try it here!\n\nYou can call this function in two slightly different ways. The first is to write (for example)\nresult = signAndValue(x)\nand the second is to write\nsgn, val = signAndValue(x)\n➤ Try both forms. What type does each result have? What happens if x=0? Look again at the function declaration: can you explain this behaviour?\n\n# Try it here!\n\nThe following function calculates the sum of the integers from n0 to N, inclusive: \\(\\sum_{n=n_0}^N n\\).\ndef sumIntegers(N, n0):\n    result = 0\n    for i in range(n0, N+1):\n        result += i\n    return result\nNote that the function definition has the upper-limit, N, as the first input argument, contrary to what one might expect - the reason for this will soon become clear.\n➤ Create the function and test it.\n\n# Try it here!\n\nIt might usually be the case that we want to start our sum at \\(n_0 = 1\\). Python allows us to provide this as a ‘default’ value for the n0 variable, by simply changing the function declaration:\ndef sumIntegers(N, n0=1):\n    result = 0\n    for i in range(n0, N+1):\n        result += i\n    return result\nNow, if we call sumIntegers with only one argument, it is assumed that this is N, and n0 receives its default value. However, if we provide two arguments, these are interpreted as N and n0 respectively.\n➤ Try it out! Can you understand how the function works?\n\n# Try it here!\n\nWe can have multiple arguments with default values. For example, we can extend our function to compute \\(\\sum_{n=n_0}^N n^{\\,p}\\) for some power \\(p\\):\ndef sumIntegers(N, n0=1, p=1):\n    result = 0\n    for i in range(n0, N+1):\n        result += i**p\n    return result\nIf we call this specifying one, two, or three arguments, they are assumed to occur in the same order as in the function declaration (i.e. N, n0, p). However, we can also explicitly specify which arguments we wish to set. For example\nresult = sumIntegers(10, p=2)\nwould calculate the sum of squares, leaving n0 set to its default value.\n➤ Try it out!\n\n# Try it here!\n\nIf inputs are not labelled, they are assumed to be provided in the same order as in the function definition. The following function displays the value of each argument: you can use it to check you understand the different ways to call a function.\ndef printArgs(a, b, c=17, d=4.3):\n    print(\"a is: \"+str(a))\n    print(\"b is: \"+str(b))\n    print(\"c is: \"+str(c))\n    print(\"d is: \"+str(d))\n➤ Check that you understand how arguments are passed to functions.\n\n# Try it here!\n\nNote that the printArgs() function above does not contain an explicit return statement. It is an example of a function that has ‘side-effects’: it does something that isn’t apparent from knowledge of its outputs. Sometimes, it is necessary to write code with side-effects, especially for data input or output. However, they are a common source of problems, and they should be avoided where possible.\nWhen you pass a variable to a function, you effectively create a copy of the information it contains (unless it is a ‘list’ or ‘array’ - more on those in a later exercise!). Changing the variable within the function does not change the value outside the function, unless you pass it back via an output. For example:\ndef increment(x):\n    x += 1\n    print(\"Inside increment, x is now \"+str(x))\n    return x\n\nx = 0\nincrement(x) # Notice that we don't do anything with the return value here\nprint(x)      # x will therefore still be zero\nx = increment(x) # This time we are updating the value of x\nprint(x)      # x will be one.\n➤ Try this out, and check you understand what’s going on.\n\n# Try it here!\n\nEarlier in this exercise, you wrote code to calculate someone’s fortnightly salary after tax.\n➤ Adapt your code to be a function and test it out. The function should take the annual salary as a (required) argument, and the tax rate as an optional argument.\n\n# Try it here!\n\nTo allow one to use your function without knowing it, you need to document it. This is usually done just after the definition of the function. This step may seem unimportant at first, but is critical for re-using your code and distributing it to other people! In Jupyter notebooks, you can press shift+tab to bring the function help.\n➤ Try this for the type() and print() functions.\n\n# Try it here!\n\nAnother way is to just call help(&lt;functionname&gt;).\n➤ Try this below.\n\n# Try it here!\n\nDocumentation is provided by writing ‘docstrings’ at the start of any function you create. These consist of blocks of text enclosed in triple inverted commas:\n\"\"\"[Documentation goes here...]\"\"\"\nIn scientific Python, docstrings usually follow a certain style, e.g.:\ndef increment(x):\n    \"\"\"increment x.\n    \n    Parameters\n    ----------\n    x : integer\n        the number you want to increament\n    \n    Returns\n    -------\n    x : integer\n        incremented x\n    \"\"\"\n    x += 1\n    print(\"Inside increment, x is now \"+str(x))\n    return x\nWriting this example will thus output\n\ndef increment(x):\n\n➤ Document your function to calculate someone’s fortnightly salary after tax and test it out.\n\n# Try it here!\n\nAs we saw earlier, each variable we create has a type. Most variables come with certain functions and attributes ‘attached’ to them, to perform various operations that are commonly-required for that data type. These can be accessed using a ‘dot’:\na = &lt;variablename&gt;.&lt;attributename&gt;\nb = &lt;variablename&gt;.&lt;functionname&gt;()\nFor example, if we create a complex number \\(z = 1+3i\\) (where \\(i = \\sqrt{-1}\\))\nz = 1 + 3j\nwe can then access two attributes and a function, - z.real - The ‘real part’ of the complex number - z.imag - The ‘imaginary part’ of the complex number - z.conjugate() - Function returning the ‘complex conjugate’ of z\nSimilarly, any floating-point number, v, comes with a v.as_integer_ratio() function that reports \\(a\\) and \\(b\\) such that \\(v = a/b\\). To see the full list of functions associated with any variable v, type help(v). You can also type v. and then hit the Tab key.\nYou may notice that some variables have a lot of attached functions that are named with double-underscores, such as x.__add__(). These are used by Python internally, and are not intended to be called directly in programs. In fact, the __add__() function is called whenever you use +: internally, x+y gets translated to x.__add__(y). We will discuss this in more detail later in the course, when we talk about ‘object-oriented programming’.",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Exercise 2 - Variables and functions</span>"
    ]
  }
]