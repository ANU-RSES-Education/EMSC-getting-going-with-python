[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EMSC - Get Going with Python",
    "section": "",
    "text": "This is a template repository for Lecture notes that include a computational component. It builds a website from the notes and includes live-links to source code that will run on binder. This template is pre-configured for courses at Research School of Earth Sciences, but is freely available for adoption elsewhere.\nI use the Quarto publication system which converts simple markdown formatted documents to webpages, pdf and slides. Quarto is designed to develop reusable content and is based around pandoc: you should be able to quickly import and convert content to the quarto version of markdown (especially if you have been using jupyter-book or myst-md - the concepts are very similar).\nTo use this repository, you will need make a fork for yourself and replace this content with your own. You will also need set a few configuration options to match the course metadata. I’m going to explain how this works.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>EMSC e-Course template</span>"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Introduction\nThis is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Basics/Ex1-IntroWebPython.html",
    "href": "Basics/Ex1-IntroWebPython.html",
    "title": "Python on the web",
    "section": "",
    "text": "Summary\n\n\n\nIn this section we’ll discover how to run a basic python script (in the web browser) and what to expect in terms of editing, reloading, printing output and saving our work.\n\n\nThere are many different ways to run python code. For the simplest tasks, a web browser is all you need to edit and run simple tasks. In this introductory session, we will use a python interpreter embedded in each web page to learn the basic language itself.\nYou will find examples of python code such as this one which contains some Python code which you can copy but which you can’t run and you can’t edit. Note that the code is highlighted (coloured) by meaning.\n\n# A simple script (with a descriptive comment)\nprint(\"Welcome to python !\")\n\nWe use these blocks to give you examples and fragments of code that you can use later. Other code blocks have a run button and they can usually be edited (and, don’t worry, they can be reset if you make a mistake). We use these live code blocks for you to try things out. Give it a go (you can’t break anything).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nGenerally, we’ll use the live code blocks as part of an exercise for you to try something specific. The exercise blocks look like this:\n\n\n\n\n\n\nExercise 1 - Run a script / edit a script\n\n\n\n\n\nThe code box in this exercise is editable. If you click in this box, and then press Shift+⏎ (i.e. hold down the Shift key on your keyboard and then hit the return key) the code will be run, and any output is displayed underneath. You can also use the run button if you prefer.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNote there is a clipboard button to copy your answer and this is quite important because it is not saved anywhere. If you want to keep answers to your exercises, have a separate notebook / editor handy.\nWhen you have finished, you can collapse this exercise:\n\n\n\n\n\n\n\n\nUsually we will collapse the exercises by default and you’ll need to open them to access the instructions and the code. We can start right now …\n\n\n\n\n\n\nExercise 2 - Calculations\n\n\n\n\n\nWe’ve already seen a couple of examples of Python code. Now let’s try making something from scratch. One thing we can do is simply use Python like a calculator!\nTry typing simple arithmetic into the code cell below and see what happens. For example, try entering\n3+17\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nYou can also use the operators *, -, / (for division), and the parentheses (). Finally, ** is used to raise a number to some power, so that \\(3^2\\) is entered as 3**2. Keep trying new calculations !\nWhat happens if you enter two lines of calculations and run ? For example:\n3+17\n5*9\nCan you think how to get both of the answers to (hint) print out ?\n\n\n\n\nComments\nIn the examples above, you may have noticed the line\n# A simple script (with a descriptive comment)\nwhich doesn’t look as though it ought to be valid Python code. This is a ‘comment’ line: the computer ignores the # and anything following it on the same line. Comments should be used to document information that helps people to understand how the code works internally. This may seem like a waste of time - but you (or your colleagues) will be grateful in two years’ time when you find you need to change something! The comment character can also be useful for ‘switching off’ lines of code without deleting them. For example, look at this piece of code:\ndef readDataFile(fp):\n    # This function assumes that fp is\n    # a valid file-like object and that the\n    # file has already been opened for reading\n    header = fp.readline()\n    # print(header)\n    [...]\nThe first three lines of comments provide information recording some of the assumptions the programmer made when writing this function (don’t worry if it doesn’t make sense yet!). The fourth comment line is a piece of code that has been ‘commented out’: we don’t want to routinely print the file header, but it is useful to be able to reinstate this easily in case we encounter problems and need to check what the function has read.\nIn fact, ‘commenting out’ code is so common that most editors provide a straightforward way to do it. If you select a block of code and press Ctrl+/ (or on a Mac, ⌘+/), the selected lines will all be changed to begin with # comment characters. Pressing Ctrl+/ again will restore the original version. Smart editors know how to do this for many different languages.\n\n\n\nSandbox\n\n\n\n\n\n\nCoding scratch space\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python on the web</span>"
    ]
  },
  {
    "objectID": "Basics/Ex2-Variables.html",
    "href": "Basics/Ex2-Variables.html",
    "title": "Variables",
    "section": "",
    "text": "Using variables\nAs you may have noticed from the above example, once we have set the value of a variable, we can use it in calculations. Thus,\nwill perform the calculation \\((3\\times 2) = 6\\), and display the answer on the screen. If we wish, we can choose to assign the result to another variable, e.g.\nNow, z contains the value 4. We can also reassign the value of a variable,\nNotice that x appears on both sides of the equals sign here. This should be read as ‘do the calculation x + y and then store the result in x (over-writing whatever was there before)’. We end up with x containing the value \\(3 + 2 = 5\\).",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables</span>"
    ]
  },
  {
    "objectID": "Basics/Ex2-Variables.html#using-variables",
    "href": "Basics/Ex2-Variables.html#using-variables",
    "title": "Variables",
    "section": "",
    "text": "x = 3\ny = 2\nprint(x * y)\n\nx = 3\ny = 2\nz = x*y - y\n\nx = 3\ny = 2\nx = x + y\n\n\n\n\n\n\n\nExercise 1 - Setting, resetting and viewing variables\n\n\n\n\n\nTry creating some variables, and using them in simple calculations. Start with the examples above. Be sure to check that the results match what you expect.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nConstructs such as x = x + y are so common that Python has a special shorthand notation for this. We can express the same equation by entering x += y. There are similar versions for other operators: -=, *= and /=.\nTry out these shorthand operators. Is x += 3 the same as 3 += x? Why / why not ?\nThere is no particular advantage to using these short forms, except convenience and readibility.",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables</span>"
    ]
  },
  {
    "objectID": "Basics/Ex2-Variables.html#naming-conventions",
    "href": "Basics/Ex2-Variables.html#naming-conventions",
    "title": "Variables",
    "section": "Naming Conventions",
    "text": "Naming Conventions\nYou can call your variables anything you like. However, following a few conventions will improve the clarity of your code:\n\nIf your variable name is made up of multiple words, either:\n\nJoin them using underscores (e.g. a_long_variable_name = 17), or\nCapitalize the first letter of each word (e.g. AnotherLongVariableName = 23.6). This is sometimes referred to as ‘camel case’ or ‘CamelCase’(since it is lower case with extra humps!).\n\nIt is common but not compulsory to use UPPER CASE for constants that should never need to be changed within the program, e.g. GRAVITATIONAL_ACCELERATION = 9.81.\nTraditionally, variables that contain integers have names beginning with the letters i, j, k, l, m, or n; variables containing real numbers start with any other letter. This comes from early programming languages (especially Fortran) where it was a requirement, and follows a similar convention in mathematics. Nowadays, this convention is often ignored for long variable names. However, if your name only contains one or two characters (e.g. a or ix), it is usual to choose the first letter appropriately. In particular, a bare i, j, k, m or n should only be used for a counting index (more on that later). If you ignore this rule, the program will work fine, but you can expect anyone who has to decipher your code in future to get more than a little bit frustrated with your choices.\n\nSome other tips:\n\nIf your code is connected to another document (e.g. you are trying to plot some equation from a paper) then use clearly-related names in both. For example, if your paper has the equation \\(y = \\alpha x +3\\gamma\\), then use the variable names x, y, alpha and gamma in your code. You can even use unicode.\nMake your variable names long enough to be clearly understood, but not too long. At most, you probably want it to be based on two or three words.\nDo not give your variable a name that has a special meaning in Python (e.g. int or sum). Doing so will not always cause problems, but it is a common source of grief.\n\nAbove all, try and develop a consistent style, and name similar quantities in similar ways. For example, the following are individually all reasonable choices for variable names:\nmass_of_helium = 4.003\nneon_mass = 20.180\nmassArgon = 39.948\nmKrypton = 83.798\nmXe = 131.293\nHowever, mixing the different styles within one program is guaranteed to cause you confusion and lead to errors. Pick one format that makes sense to you, and stick with it.\n\nTypes\nAny and every variable has a type. We can ask Python to report on the type of a given variable by using the command type(variable_name). For example,\na = 3\ntype(a)\nwill print int (shorthand for ‘integer’), while\na = 3.0\ntype(a)\nwill print float (i.e., floating-point). We will encounter other types in due course.\n\n\n\n\n\n\nExercise 2 - Variables and their types\n\n\n\n\n\nTry creating some variables, and using them in simple calculations. Start with the examples above. Be sure to check that the results match what you expect.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWhat happens if you mix different types, ?\ni = 2\na = 3.0 * i\nprint(type(i), type(a))\nprint(a)\n\nprint(i / 2)\nprint(i / 3)",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables</span>"
    ]
  },
  {
    "objectID": "Basics/Ex2-Variables.html#application-salary-calculations",
    "href": "Basics/Ex2-Variables.html#application-salary-calculations",
    "title": "Variables",
    "section": "Application: Salary calculations",
    "text": "Application: Salary calculations\nLet’s try doing a real-world calculation. Suppose your annual salary is $ 164,402, and the annual tax rate is 35%. How much money should be paid into your bank account every two weeks?\nWhat if you happened to be a famous musician in 1960s London, where the tax rates were more progressive. Suppose you earn $1,987,232 and the tax rate is just 20% on the first $50,000 that you earn, and 95% on the remainder.\n\n\n\n\n\n\nExercise 3 - Taxman\n\n\n\n\n\nCalculate your fortnightly pay as a non-musical researcher Remember, break the problem down into individual steps, and create variables for each of the quantities involved! You should find the answer is $ 4110.06.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow repeat the calculation for the higher-income scenario. Wait, isn’t that the same ?\n\n  Let me tell you how it will be\n  There’s one for you, nineteen for me\n  ’Cause I’m the taxman\n  Yeah, I’m the taxman\n  Should five percent appear too small\n  Be thankful I don’t take it all\n  ’Cause I’m the taxman\n  Yeah, I’m the taxman\n\n  Taxman George Harrison, Revolver\n\n\n\n\nVariables are more than just variables\nAs we saw earlier, each variable we create has a type. Most variables come with certain functions and attributes ‘attached’ to them, to perform various operations that are commonly-required for that data type. These can be accessed using a ‘dot’:\na = &lt;variablename&gt;.&lt;attributename&gt;\nb = &lt;variablename&gt;.&lt;functionname&gt;()\nFor example, if we create a complex number \\(z = 1+3i\\) (where \\(i = \\sqrt{-1}\\))\nz = 1 + 3j\nwe can then access two attributes and a function, - z.real - The ‘real part’ of the complex number - z.imag - The ‘imaginary part’ of the complex number - z.conjugate() - Function returning the ‘complex conjugate’ of z\nSimilarly, any floating-point number, v, comes with a v.as_integer_ratio() function that reports \\(a\\) and \\(b\\) such that \\(v = a/b\\). To see the full list of functions associated with any variable v, type help(v). You can also type v. and then hit the Tab key.\n\n\n\nSandbox\n\n\n\n\n\n\nCoding scratch space\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variables</span>"
    ]
  },
  {
    "objectID": "Basics/Ex2a-Functions.html",
    "href": "Basics/Ex2a-Functions.html",
    "title": "Functions",
    "section": "",
    "text": "Functions\nA function provides a convenient way to ‘wrap up’ code to accomplish a particular task. Once a function is written, it can (generally) be used without us needing to know anything about how it works. This is a very powerful concept, and complex programs are often made by chaining many functions together.\nIn general, a function has a well-defined set of inputs (sometimes known as the function’s ‘arguments’) and outputs (sometimes called the ‘return value’). In Python, and most other modern programming languages, a ‘function call’ looks like\nWe have already encountered a couple of functions: we have used print() and type(). These are known as ‘built-in functions’, as they are a core piece of the Python programming language. For a full list of built-ins, see this page of the official Python documentation. Other functions can be accessed by ‘importing’ them from ‘modules’ - we will learn more about this later.\nIt is easy to write your own functions. This is done by using the def command, and writing something like:\nNote that function_name, input1, output1 etc can be any name you wish to use. In general, a function definition comprises: - The keyword def, followed by - The function name, followed by - An opening parenthesis (, followed by - Zero or more input variables, followed by - A closing parenthesis ), followed by - A colon, :\nThis is all followed by an indented block of code containing zero or more lines of the form - The keyword return, followed by - Zero or more variable names (or valid expressions)\nFor example\nWe can then ‘call’ this function:\nThe variable result should now contain the value 7 (= 3 + 5 - 1).\nA few things to notice from this example: - When we ‘call’ (use) a function, we can give it both named variables (a and b), and values (-1). - The variable names we pass to the function don’t need to match the variable names used when ‘declaring’ (defining) the function - so we can use a and b instead of first and second. - The return keyword specifies what the function result will be.\nHere’s a slightly more complicated example, which calculates the sign and absolute value of the input (unless it is zero):",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "Basics/Ex2a-Functions.html#functions",
    "href": "Basics/Ex2a-Functions.html#functions",
    "title": "Functions",
    "section": "",
    "text": "output1, output2 = function_name(input1, input2, input3)\n\n\ndef function_name(input1, input2, input3):\n    [code to compute outputs...]\n    return output1,output2\n\n\n\ndef addThreeNumbers(first, second, third):\n    return first + second + third\n\na = 3\nb = 5\nresult = addThreeNumbers(a, b, -1)\n\n\n\n\n\n\n\nExercise 1 - Create a python function\n\n\n\n\n\nCreate the addThreeNumbers function and try it out\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\ndef signAndValue(x):\n    if x == 0:\n        print(\"Unable to handle zero\")\n    elif x &gt; 0:\n        return +1, x\n    else:\n        return -1, -x\n\n    print(\"Hope that helps !\")\n\n\n\n\n\n\nExercise 2 - Exploring how functions work\n\n\n\n\n\nTry creating this function and see how it behaves. Some things to think about: - When is the message “Hope that helps !” printed? Why? -\nWhat form does the function result have? What is its type? What about if x has the value 0 ? - What is the role of if/elif/else? (We’ll deal with that question in the next section, but it should be clear enough)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nYou can call this function in two slightly different ways. The first is to write (for example)\nresult = signAndValue(x)\nand the second is to write\nsgn, val = signAndValue(x)\nTry both forms. What type does each result have? What happens if x is 0 ? Look again at the function declaration: can you explain this behaviour?\n\n\n\n\nFunction arguments\nThe following function calculates the sum of the integers from n0 to N, inclusive: \\(\\sum_{n=n_0}^N n\\).\ndef sumIntegers(N, n0):\n    result = 0\n    for i in range(n0, N+1):\n        result += i\n    return result\nNote that the function definition has the upper-limit, N, as the first input argument, contrary to what one might expect - the reason for this will soon become clear.\nIt might usually be the case that we want to start our sum at \\(n_0 = 1\\). Python allows us to provide this as a ‘default’ value for the n0 variable, by simply changing the function declaration:\ndef sumIntegers(N, n0=1):\n    result = 0\n    for i in range(n0, N+1):\n        result += i\n    return result\nNow, if we call sumIntegers with only one argument, it is assumed that this is N, and n0 receives its default value. However, if we provide two arguments, these are interpreted as N and n0 respectively.\nWe can have multiple arguments with default values. For example, we can extend our function to compute \\(\\sum_{n=n_0}^N n^{\\,p}\\) for some power \\(p\\):\ndef sumIntegers(N, n0=1, p=1):\n    result = 0\n    for i in range(n0, N+1):\n        result += i**p\n    return result\nIf we call this specifying one, two, or three arguments, they are assumed to occur in the same order as in the function declaration (i.e. N, n0, p). However, we can also explicitly specify which arguments we wish to set. For example\nresult = sumIntegers(10, p=2)\nwould calculate the sum of squares, leaving n0 set to its default value.\nIf inputs are not labelled, they are assumed to be provided in the same order as in the function definition. The following function displays the value of each argument: you can use it to check you understand the different ways to call a function.\ndef printArgs(a, b, c=17, d=4.3):\n    print(\"a is: \"+str(a))\n    print(\"b is: \"+str(b))\n    print(\"c is: \"+str(c))\n    print(\"d is: \"+str(d))\n\n\n\n\n\n\nExercise 3 - Optional Arguments / defaults\n\n\n\n\n\nHere is the original form of sumIntegers which you can now validate to see if it works as you expected.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow modify the function to have n0 be an optional argument with a default value. Does this work as you expected ? When would this behaviour be useful ?\nRun the printArgs function for these cases:\n\nprintArgs(1, 2, 3, 4)\nprintArgs(1, 2, 'a', (1,2,3) )\nprintArgs(2, 1, d=4, c=3 )\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n**Modify the printArgs function to return the type as well as the value of each argument. Does the default definition set the type ?\n\n\n\nNote that the printArgs() function above does not contain an explicit return statement. It is an example of a function that has ‘side-effects’: it does something that isn’t apparent from knowledge of its outputs. Sometimes, it is necessary to write code with side-effects, especially for data input or output. However, they are a common source of problems, and they should be avoided where possible.\n\n\nScope of variables in functions\nWhen you pass a variable to a function, you effectively create a copy of the information it contains (unless it is a ‘list’ or ‘array’ - more on those in a later exercise!). Changing the variable within the function does not change the value outside the function, unless you pass it back via an output. For example:\ndef increment(x):\n    x += 1\n    print(\"Inside increment, x is now \"+str(x))\n    return x\n\nx = 0\n\nincrement(x) # Notice that we don't do anything with the return value here\nprint(x)      # x will therefore still be zero\nx = increment(x) # This time we are updating the value of x\nprint(x)      # x will be one.\n\n\n\n\n\n\nExercise 4 - Variables within functions\n\n\n\n\n\nTry this out, and check you understand what’s going on.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIf you leave out the global x then x will be undefined in the function as it does not have access to outside variables.\n\n\n\nThere is a way to access external (global) variables from within functions. They might be used in this situation:\n\nsystem_is_setup = False\n\n\ndef setup():\n    global system_is_setup\n    if system_is_setup == False:\n        # Do system setup tasks\n        ...\n    else:\n        # check system is ok    \n        ...\n    \n    return \n\nGenerally speaking, functions using global variables in this way is a poor choice of implementation because some hidden code is modifying the global state without us, as users, being in control or even aware. We do often define variables of this nature when we use python objects that have a special internal (private) state. We will learn about this later.\n\n\nFunction documentation\nTo allow anyone to use your function without knowing the details, you need to document it. This appears in the code just after the definition of the function (and other python entities too). This step may seem unimportant at first, but is critical for re-using your code and distributing it to other people ! Another way is to just call help(&lt;functionname&gt;) and it will output the documentation.\n\nhelp(print)\n\n    Help on built-in function print in module builtins:\n\n    print(\\*args, sep=' ', end='\\n', file=None, flush=False) \n        Prints the values to a stream, or to sys.stdout by default.\n        \n    sep\n        string inserted between values, default a space.\n    end\n        string appended after the last value, default a newline.\n    file\n        a file-like object (stream); defaults to the current sys.stdout.\n    flush\n        whether to forcibly flush the stream.\nDocumentation is provided by writing ‘docstrings’ at the start of any function you create. These consist of blocks of text enclosed in triple inverted commas:\n\"\"\"[Documentation goes here...]\"\"\"\nIn scientific Python, docstrings usually follow a certain style, e.g.:\ndef increment(x):\n    \"\"\"increment x.\n    \n    Parameters\n    ----------\n    x : integer\n        the number you want to increament\n    \n    Returns\n    -------\n    x : integer\n        incremented x\n    \"\"\"\n    x += 1\n    print(\"Inside increment, x is now \"+str(x))\n    return x\n\n\n\n\n\n\nExercise 4 - Documentation of a function\n\n\n\n\n\nCheck how the documentation string for the increment function works: try changing the documentation to see what happens. Do spaces matter ? Does it matter if the docstring is positioned exactly by the def increment(x): line ?\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow do the same for the sumIntegers function taking care to indicate default values and what they mean.\n\n\n\n\n\n\nSandbox\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "Basics/Ex3-Conditionals.html",
    "href": "Basics/Ex3-Conditionals.html",
    "title": "Conditional expressions",
    "section": "",
    "text": "Summary\n\n\n\nIn this section we introduce conditional execution which allows us to write algorithms that change their behaviour depending on the nature of the inputs provided.\n\n\nConditional expressions allow us to alter the behaviour of our program depending on the circumstances. To do this, we employ an if...elif...else construct, which takes the form:\nif &lt;condition&gt;:\n    [...]\nelif &lt;another condition&gt;:\n    [...]\nelse:\n    [...]\nHere, each &lt;condition&gt; is a ‘logical’ expression - something which is either ‘true’ or ‘false’. Each [...] denotes a block of code that is only executed if the condition is met. We can have as many elif (‘else if’) blocks as we wish, and we can omit the elif and/or else blocks entirely. At most, one block will be executed: each is tried in the order they appear in the program, until one is found for which &lt;condition&gt; is True. Notice that the else block does not have a condition - this is executed if none of the other conditions are met.\nTo make this clearer, here’s a real example, inside a function:\ndef condExample(x):\n    if x&lt;0:\n        print(\"x is negative\")\n    elif x&lt;=1:\n        print(\"x is between 0 and 1 (inclusive)\")\n    else:\n        print(\"x is greater than 1\")\n\n\n\n\n\n\nExercise 1 - if / elif / else\n\n\n\n\n\nTry this function. Does everything behave as you would expect? Try deleting the elif and/or else clauses; how does this affect the output ?\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nLogical expressions\nLogical expressions are calculations that result in either True or False. As we have already seen, they often arise by comparing the value of two variables (or a variable and a constant), such as x &gt; 0. The comparison operators are:\n\n\n\nOperator\nMeaning\n\n\n\n\n&gt;\nGreater than\n\n\n&lt;\nLess than\n\n\n&gt;=\nGreater than or equal to\n\n\n&lt;=\nLess than or equal to\n\n\n==\nEqual to\n\n\n!=\nNot equal to\n\n\n\nYou can check you understand how these work by testing expressions in a Python cell: for example, entering\n3 &gt; 5\nshould evaluate to False.\nNote: an important point is that the constants True or False are Booleans, and not text. So \"True\" (string) is very different of True (Boolean). A possible mistake is to confound them and use \"True\" instead of True. In general, as soon as you want to use something based on a true/false behavior, use Boolean constants in your program.\nTo build more complicated expressions, you can use the Boolean operators and, or and not. An expression of the form A and B is only True if both A and B are separately True. On the other hand, A or B is True if either (or both) of A and B are themselves True. The not operator flips True to False, and vice versa. You can use parentheses to group expressions if necessary.\nFor example:\nx &gt; 3 and (y == 2 or not (y &gt; 3 and x+y ==4) )\nMany logical conditions can be expressed in multiple forms, for example x &gt; 3 is identical to not x &lt;= 3. In general, you should use the simplest form that is appropriate to your circumstances.\nN.B. In some other languages, the symbols & and | are used for and and or. In Python, these symbols are ‘bitwise’ operators, and they will not give the results you expect. We will avoid using them in this course.\n\n\n\n\n\n\nExercise 2 - &lt;, &gt;, ==\n\n\n\n\n\nTest each of the operators to see if they work as expected. Be careful with the == in real programs x==3 returns True or False but, if you make a typo, x=3 will change x quietly (but 3==x is a valid test, 3=x is a SyntaxError)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nTry using the and, or and not operators.\n\n\n\n\n\nTesting for None\nAnother logical operator you may encounter is is. This is used to test whether two variable names refer to the same entity. This is stronger than simply testing for equality. For example:\na = 300\nb = 300\nprint(a is b)\nprint(a == b)\na is b will return False, whereas a is a returns True. This may seem like a pointless detail, but we can define the == and is differently for complicated data structures and objects.\nIt can also be useful to distinguish between a value that has not been set, and a value that is False or 0 etc. where the logical tests may produce unexpected positives. You will often see a null default value within a function:\ndef printHello(name=None):\n    if name is None:\n        print(\"Hello, what is your name?\")\n    else:\n        print(\"Hello \"+name)\n\n\n\nSandbox\n\n\n\n\n\n\nCoding scratch space\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Conditional expressions</span>"
    ]
  },
  {
    "objectID": "Basics/Ex4-Loops.html",
    "href": "Basics/Ex4-Loops.html",
    "title": "Loops",
    "section": "",
    "text": "Summary\n\n\n\nIn this section we introduce loops that allow repeated execution of an algorithm with a defined series of input values.\n\n\nMuch of the power in programming comes from being able to repeat calculations, and change how our program works depending on the values of certain variables along the way. To achieve this, we need to employ ‘loop expressions’ and build on our use of ‘conditional expressions’.\nLoops allow you to repeat a series of calculations a number of times, or until certain conditions are met. In Python, there are two main loop formats.\n\nThe while loop\nThe first is a while loop:\nwhile &lt;condition&gt;:\n    [...]\nHere, &lt;condition&gt; is a logical expression (just like those discussed above). If this evaluates to True, the block of code ([...]) is executed in its entirety. The condition is then evaluated again, and the entire process repeats until it becomes False. For example, here is a loop that keeps doubling a number until it exceeds some threshold:\nx = 1\nwhile x&lt;100:\n    x += x\nprint(x)\nNormally, the entire indented block of code below the while statement is executed before the condition is checked again. However, two commands can be used to alter this:\n\nThe break keyword terminates the loop, jumping to the first statement after the indented block\nThe continue keyword skips over any remaining code within the indented block, but returns to re-evaluate the &lt;condition&gt;, and if this is True will execute the indented block as before.\n\nThese two commands are almost invariably used in conjunction with an if statement.\nFor example:\nx = 1\nwhile x &lt; 100:\n    x+=5\n    if x == 71: \n        break\n    if x%2 == 0: \n        continue # Skip even values of x\n    print(\"In loop: x=\", x)\n\nprint(\"After loop: x=\", x)\nIf you run this code, you will see that it never prints an even number (since the print statement is after the continue in this case, and so doesn’t get executed); moreover, the loop terminates at x=71, due to the break statement.\n\n\n\n\n\n\nExercise 1 - While loop\n\n\n\n\n\nTry the while loop example above and modify to see how it works\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWhen you run the while loop code above, you will see that it never prints an even number (since the print statement is after the continue in this case, and so doesn’t get executed); moreover, the loop terminates at x=71, due to the break statement.\n\n\n\n\n\n\n\n\n\nInfinite loops\n\n\n\n\n\nInfinite loops can occur if you have no break statement or explicity exit condition.\nInfinite loops will run endlessly if not manually stopped (by sending a termination signal), and are a well known problem since the dawn of computer programming. You will waste a lot of energy if you let the computer spin its wheels this way.\n\n\n\n\n\nBreaking to exit a loop\nSometimes, it may be appropriate to use the following style:\nwhile True:\n    [...]\n    if &lt;condition&gt;: break\n    [...]\nHere, the loop condition is always True, creating an infinite loop. However, the use of a break allows us to escape from the loop.\n\n\n\n\n\n\nExercise 2 - problem solving (i)\n\n\n\n\n\nSuppose you start with an empty basket and you want to pick apples on a tree. You will make 100 picking moves.\nYou start by picking 2 apples at a time, but after doing this 50 times you get bored. You then pick 5 apples each time, and after doing this a further 25 times, you start picking 10 apples.\nWrite a function containing a loop to return the number of apples in your basket after each pick\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\n\n\n\nExercise 3 - problem solving (ii)\n\n\n\n\n\nSuppose you take out a $$$500,000 mortgage to buy a house. You make a repayment of $2,000 each month. However, each month the bank charges interest at a rate of 0.3% of the outstanding balance. How many months will it take you to pay off the debt? How much does it cost you?\nWrite a function to calculate this information for any loan amount, interest rate and monthly repayment. Print the amount outstanding each month\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nNote: there are other loops that we can use in python (e.g. the for loop) and we will see these later.\n\n\n\nSandbox\n\n\n\n\n\n\nCoding scratch space\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Loops</span>"
    ]
  },
  {
    "objectID": "Basics/Ex5-ListsEtc.html",
    "href": "Basics/Ex5-ListsEtc.html",
    "title": "Lists, tuples and dictionaries",
    "section": "",
    "text": "Lists\nA list is defined by using square brackets, [ and ], and consists of some set of entries separated by commas, e.g.,\nThe individual entries do not need to have the same type. Also, we can have lists inside lists, e.g.,\nalthough in practice, list elements tend to be more homogenous than the example above.\nWe can access individual entries in the list by adding an index to the variable name. In Python, we have to remember a quirk: when counting objects, we start from 0 rather than from 1; this is because Python is a 0-based programming language. Thus, to access the first entry in the list a, we use a[0]; the second entry is a[1]. We can use these entries in calculations.\nThus:\nWhere an entry in a list is itself a list, we can use a second index to access the elements of this:\nNegative indices count from the last element in the array, which is accessible as a[-1].\nWe can also ask for a range of entries. To do this, we specify the index of the first entry we want, and an index one larger than that of the last entry we want, separated by a colon:\nAgain, this is somewhat quirky. However, it does mean that if we want to extract n entries starting at index i0, we simply need to ask for a[i0:i0+n]. By default, we get every element in the requested range. However, if we only want every \\(k\\)-th element, we can specify k after a second colon, .e.g,\nFinally, we can use shorthands such as a[:4] (everything from the start up to element a[3], inclusive), a[3:] (everything from a[3] to the end) and a[::2] (every second element, starting with a[0]).\nWe can change the values stored within an element of a list:\nLists are therefore said to be ‘mutable’. However, note that we need to explicitly change the list entry:\nUnlike most other variables in Python, a list variable stores a reference to the list, rather than the list itself. This means that two different variable names can refer to the same memory address, and is a common (and counter-intuitive) source of errors. For example\nNotice that the list referred to by a has changed, even though we have not explicitly altered it! This behaviour is different from ‘normal’ variables.\nIf you wish to create a copy of a list, you will need to use the ‘copy’ function:\nIf we ‘add’ two lists together, we create a new list containing the elements from each:\nOne can ‘grow’ a list:\nHowever, if you need to build a large list, this is a very inefficient way of doing it, and your program will probably end up being very slow.\nPython provides a number of standard functions for working with lists. A few of the more important ones are detailed below, where we suppose a is a list:\n➤ Try these out! Explore how each of the functions works. Remember, you can get information about any function by typing &lt;function-name&gt;? and hitting shift-enter, e.g. a.pop?.\n# Try it here!\n➤ In the previous exercise, you wrote code for a guessing game. Adapt this to keep a record of all the user’s past guesses, and detect when the user repeats a previous (incorrect) guess.\n# Try it here!",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Lists, tuples and dictionaries</span>"
    ]
  },
  {
    "objectID": "Basics/Ex5-ListsEtc.html#lists",
    "href": "Basics/Ex5-ListsEtc.html#lists",
    "title": "Lists, tuples and dictionaries",
    "section": "",
    "text": "a = [3, 4, 5]\n\na = [3.2, 'hello', [4, 8, 17.1]] \n\n\n\na = [3.2, 'hello', [4, 8, 17.1]] \nprint(a[0])                  # Prints '3.2'\nprint(a[1])                  # Prints 'hello'\nprint(a[2])                  # Prints '[4, 8, 17.1]'\nprint(2+a[0])                # Prints '5.2'\n\na = [3.2, 'hello', [4, 8, 17.1]]\nprint(a[2])                 # Prints '[4, 8, 17.1]'\nprint(a[2][0])              # Prints '4'\nprint(a[2][1]**2 - a[2][2]) # Prints '46.9'\n\n\na = [5, 6, 7, 8, 9]\nprint(a[1:3])               # Prints [6, 7]\n\na = [5, 6, 7, 8, 9, 10, 11, 12]\nprint(a[1:6:2])             # Prints '[6, 8, 10]'\n\n\na = [1, 2, 3]\nprint(a[1]) # Prints '2'\na[1] = 17\nprint(a) # Prints '[1, 17, 3]'\n\nx = 3\na = [1, 2, x]\nprint(a) # Prints '[1, 2, 3]'\nx = 5\nprint(a) # Still prints '[1, 2, 3]'\n\n\n\n\n\n\nExercise 1 - Do you understand lists\n\n\n\n\n\nCheck the examples given above\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWrite a loop to populate a list with a sequence of numbers. Write a second loop to create another list which has the square of each number but in reverse order from the first one\nDon’t forget to validate your results. Write a check to ensure the first and last entries of the list are correct.\n\n\n\n\na = [1, 2, 3]\nb = a # 'a' and 'b' both refer to the same object\nprint(a)     # Prints '[1, 2, 3]'\nb[1] = 17\nprint(a)     # Prints '[1, 17, 3]'\n\n\n\n\n\n\n\nExercise 2 - lists passed to functions\n\n\n\n\n\nBecause lists are stored as references to data, changes to a list made in a function call are global. Demonstrate that this is true\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow you know - be careful !\n\n\n\n\na = [1, 2, 3]\nb = a.copy()\nb[1] = 17\nprint(a)     # Prints '[1, 2, 3]'\n\na = [1, 2, 3]\nb = [4, 5, 6]\nprint(a + b) # Prints '[1, 2, 3, 4, 5, 6]'\n\na = [1, 2, 3]\na += [4]\nprint(a)     # Prints '[1, 2, 3, 4]'\n\n\n\nlen(a) returns the length of a, i.e. the number of elements it contains,\nmax(a) returns the largest element of a,\nmin(a) returns the smallest element of a,\nsum(a) returns the sum of the elements of a,\na.sort() sorts the elements of a,\na.append(x) adds a new element at the end of the listw, containing the contents of x,\na.insert(i, x) adds a new element containing x at location `a[i]``, shifting later elements ‘backwards’ by one,\na.remove(x) finds the first occurrence of x in the list and removes it,\na.count(x) counts the number of occurrences of x in the list,\na.index(x) returns the index of the first occurrence of x in the list,\na.reverse() flips the order of elements in a list, and\na.pop(i) removes and return the element at index i in the list (or if no argument is provided, the last element in the list).",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Lists, tuples and dictionaries</span>"
    ]
  },
  {
    "objectID": "Basics/Ex5-ListsEtc.html#tuples",
    "href": "Basics/Ex5-ListsEtc.html#tuples",
    "title": "Lists, tuples and dictionaries",
    "section": "Tuples",
    "text": "Tuples\nA tuple is rather similar to a list, but is defined using round brackets, ( and ), e.g.,\na = (3, 'x', (1, 2, 3))\nAgain, tuples can contain multiple elements, and the elements may not all share the same type. The key difference is that tuples are immutable, so that once a tuple is created it cannot subsequently be changed. (It can be extended – but this is effectively the creation of a new, larger tuple!) As with lists, the individual elements of a tuple can be accessed using [index] after the tuple name, e.g.\na = (3, 4, 5)\nprint(a[1]) # Prints `4`\nAgain, Python provides a number of functions for working with a tuple (‘a’), including: - len(a) - min(a) - max(a) - a.index(x) - a.count(x)\nall of which are similar to their counterparts for lists.\n➤ Try it out!\n\n# Try it here!\n\nA tuple can be converted into a list, and vice versa:\na = [3, 4, 5]\nb = (6, 7, 8)\nta = tuple(a)\nlb = list(b)\nWhen should you use a tuple, and when should you use a list? To some extent, this is a matter of style and preference. In general, the advice is that all the entries in a list should be ‘the same kind of data’, whereas the entries in a tuple are likely to represent different entitites. For example, if we have an experimental dataset that consists of observations of pressure and temperature at a sequence of time points, it might be appropriate to represent each observation as a tuple of (pressure, temperature), and then the sequence of observations as a list of these tuples [(p1, T1), (p2, T2), (p3, T3),...].",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Lists, tuples and dictionaries</span>"
    ]
  },
  {
    "objectID": "Basics/Ex5-ListsEtc.html#dictionaries",
    "href": "Basics/Ex5-ListsEtc.html#dictionaries",
    "title": "Lists, tuples and dictionaries",
    "section": "Dictionaries",
    "text": "Dictionaries\nDictionaries provide a mechanism for storing data labelled with a keyword or other information. To create a dictionary, we use curly brackets, and associate each piece of data with a label:\na = {&lt;label1&gt;: &lt;data1&gt;, &lt;label2&gt;: &lt;data2&gt;}\nAnother syntax to create dictionaries is:\na = dict(&lt;label1&gt;=&lt;data1&gt;, &lt;label2&gt;=&lt;data2&gt;)\nFor example, if we wished to store an object’s mass, location and length, we might create a dictionary as follows:\na = {'mass': 17.3, 'length': 0.7, 'location': (3, 1, 8)}\nor\na = dict(mass=17.3, length=0.7, location=(3, 1, 8))\nNote that in this example, the location key is storing a tuple. This illustrates that you can store many things in dictionaries, including arrays, list, tuples or objects for instance.\nNow, we can use the keywords as an index:\nprint(a['mass'])\nprint(a['length'])\ninertia = 0.5 * a['mass'] * a['length']**2\nprint(inertia)\nOften keywords will be text strings, but they do not need to be:\ny = (3, 4, 5)\na = {2: '13.5', y: [6, 7, 8]}\nprint(a[2])\nprint(a[y])\nYou can add new entries to a dictionary by simply assigning to the indexed entry you wish to create:\na = {'name': 'Bob'}\nprint(a['name']) # Prints 'Bob'\n# print(a['age']) would not work at this point\na['age'] = 28\nprint(a) # Now contains both 'name' and 'age'.\n➤ Try it out!\n\n# Try it here!\n\nAgain, Python provides a number of functions that work with dictionaries, many of which we have already encountered, including: - len(a) - max(a) - min(a) - a.copy() - a.pop()\nSome methods particular to dictionaries are: - a.keys() - returns a list-like object containing all the ‘labels’ within the dictionary a, - a.values() - returns a list-like object containing all the ‘values’ within the dictionary a, and - a.items() - returns a list-like object containing (label, data) tuples for each of the entries in the dictionary.\n➤ Try them all out!\n\n# Try it here!\n\nDictionaries provide a useful mechanism for storing miscellaneous, unstructured information, such as metadata. The use of human-readable labels makes it easy to remember what each entry represents.\nSome properties of the first few elements in the periodic table are given below. Melting and boiling points are determined at atmospheric pressure.\n\n\n\n\n\n\n\n\n\n\nElement\nSymbol\nAtomic Number\nMelting point (K)\nBoiling point (K)\n\n\n\n\nHydrogen\nH\n1\n14\n20\n\n\nHelium\nHe\n2\n1\n4\n\n\nLithium\nLi\n3\n453\n1603\n\n\nBeryllium\nBe\n4\n1560\n2742\n\n\nBoron\nB\n5\n2349\n4200\n\n\nCarbon\nC\n6\n3915\n3915\n\n\nNitrogen\nN\n7\n63\n77\n\n\nOxygen\nO\n8\n54\n90\n\n\nFluorine\nF\n9\n53\n85\n\n\nNeon\nNe\n10\n25\n27\n\n\n\n➤ Create a dictionary to store this information, indexed by the symbol. Then write a function which allows the user to specify an element (via its symbol) and a temperature, and which reports whether the element is solid, liquid or gas at that point.\n\n# Try it here!\n\nIn a previous exercise, you wrote code to calculate mortgage repayments. Different banks are offering different interest rates, with special introductory rates for the first two years of the mortgage:\n\n\n\nBank name\nYears 1 & 2\nYear 3 onwards\n\n\n\n\nANZ\n2.3%\n4.1%\n\n\nBank of Australia\n0.1%\n5%\n\n\nCommonwealth Bank\n3.5%\n3.8%\n\n\nWestpac\n3.7%\n3.7%\n\n\n\n➤ Use a dictionary to store this information, and modify your function so that the user can specify which bank provides their mortgage. You can assume that the monthly interest rate is simply one-twelfth of these annual rates.\n\n# Try it here!",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Lists, tuples and dictionaries</span>"
    ]
  },
  {
    "objectID": "Basics/Ex5-ListsEtc.html#sets",
    "href": "Basics/Ex5-ListsEtc.html#sets",
    "title": "Lists, tuples and dictionaries",
    "section": "Sets",
    "text": "Sets\nFinally, we briefly mention the set data type. This is not commonly encountered, but can be very useful. It implements the mathematical concept of a set, an unordered collection of unique objects. A set can be created from a tuple or list:\na = [3, 4, 5]\ns = set(a)\nprint(s) # prints {3, 4, 5}\nDuplicates are ignored:\na = [3, 3, 5]\ns = set(a)\nprint(s) # prints {3, 5}\nWe can test whether one set is a subset of another set (that is, whether every element of the first set is also in the second) using the &lt;,&gt;, &lt;= and &gt;= operators:\nset([3, 4]) &lt; set([3, 4, 5]) # True\nset([3, 4, 5]) &lt; set([3, 4, 5]) # False\nset([3, 4, 5]) &lt;= set([3, 4, 5]) # True\nWe can find the union of two sets - the set of all elements in either set - using the | operator, and the intersection - all elements shared between the sets - using the & operator:\na = set([3, 4]) \nb = set([4, 5, 6])\n\nprint(a | b) # prints {3, 4, 5, 6}\nprint(a & b) # prints {4}\nWe can also use the operator - to remove the elements of one set from another set.\na = set([3, 4]) \nb = set([4, 5, 6])\n\nprint(b - a) # prints {5, 6}\nprint(b^a) # prints {3, 5, 6}\nThere is also a ^ operator, which is defined such that a^b is equivalent to (a|b) - (a&b).\n\n# Try it here!",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Lists, tuples and dictionaries</span>"
    ]
  },
  {
    "objectID": "Basics/Ex6-MoreLoops.html",
    "href": "Basics/Ex6-MoreLoops.html",
    "title": "More about loops",
    "section": "",
    "text": "Prime numbers\nThe Sieve of Eratosthenes is a method for finding prime numbers (i.e., integers which are not divisible by any other integers except themselves and one). Suppose you want to find all the prime numbers less than or equal to 25. First, you write down a list of all the numbers from 2 up to 25:\nNow, you start crossing out numbers. First, we consider the first entry in the list, 2. We keep this, but cross out every second number thereafter:\nWe move our pointer to the next not-crossed-out number, 3. We then cross out every 3rd entry (counting ones that are already crossed out):\nThe next not-crossed out number is 5, so we remove every 5th entry:\nIf we continue this procedure, we will find that we do not cross out any more numbers. The remaining numbers - 2, 3, 5, 7, 11, 13, 17, 19 and 23 - are all the primes less than (or equal to) 25.\n➤ Write a function that takes a single input, \\(N\\), and returns the list of all prime numbers less than \\(N\\).\n# Try it here!",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>More about loops</span>"
    ]
  },
  {
    "objectID": "Basics/Ex6-MoreLoops.html#prime-numbers",
    "href": "Basics/Ex6-MoreLoops.html#prime-numbers",
    "title": "More about loops",
    "section": "",
    "text": "2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n\n2 3 X 5 X 7 X 9 X 11 X 13 X 15 X 17 X 19 X 21 X 23 X 25\n^Start here\n\n2 3 X 5 X 7 X X X 11 X 13 X X X 17 X 19 X X X 23 X 25\n  ^Start here\n\n2 3 X 5 X 7 X X X 11 X 13 X X X 17 X 19 X X X 23 X X\n      ^Start here",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>More about loops</span>"
    ]
  },
  {
    "objectID": "Basics/Ex7-Strings.html",
    "href": "Basics/Ex7-Strings.html",
    "title": "Strings",
    "section": "",
    "text": "The ‘Caesar’ cipher\nAs we have already discussed, every piece of information within a computer must be organised and represented in binary form. This implies that the sequence of letters in the alphabet can be mapped onto the set of integers, and this is usually done via the ‘ASCII’ code sequence.\nPython provides the function chr(integer) to convert integers into their ASCII alphanumeric equivalent.\n➤ Write a loop to print the integers from 33 up to 128, and their ASCII equivalents. (The first 32 ASCII codes are special control characters, and do not have alphanumeric equivalents).\n# Try it here!\nA ‘Caesar cipher’ is a very simple way to hide a message making it difficult for someone to read. To encode a piece of text with a Caesar cipher, we simply shift each letter \\(N\\) places up (or down) the alphabet. For example, choosing \\(N=1\\), the message\nwould become\nbecause ‘J’ is one letter after ‘I’, ‘m’ is one after ‘l’, and so on.\n➤ Write a function to encode messages using Caesar ciphers (for any choice of \\(N\\)). Note that the ‘decoder’ is simply the ‘encoder’, but instead using \\(-N\\).\n# Try it here!\nHere is a message encoded using a Caesar cipher:\n➤ By looping through all possible values of \\(N\\), find the \\(N\\) used to encode this message and decode it.\n# Try it here!",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "Basics/Ex7-Strings.html#the-caesar-cipher",
    "href": "Basics/Ex7-Strings.html#the-caesar-cipher",
    "title": "Strings",
    "section": "",
    "text": "I like Python\n\nJ mjlf Qzuipm\n\n\n\n\nPfl yrmv wzezjyvu kyzj vovitzjv",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "Basics/Ex8-ReadWriteFiles.html",
    "href": "Basics/Ex8-ReadWriteFiles.html",
    "title": "Reading and writing files",
    "section": "",
    "text": "Summary\n\n\n\nIn this section we learn about data-file handling (reading / writing information) which is a pre-cursor to doing useful computing at scale. We will use some very low-level tools to read and write to storage. In practice, we would probably use packages that can read common data formats, download data from the web, or work with datasets that are too large to read all at once.\n\n\nUp to this point, we have typed all the data for our programs in ‘by hand’. However, as you have no doubt noticed, this quickly gets tedious. It is useful to be able to read and write data files, allowing information to be stored and shared with other people.\nIn order to read a data file, we need to understand what information it contains, and how this has been encoded. This is generally referred to as the ‘file format’. Different programs produce files in different formats - a photograph in .jpeg format cannot be read by a spreadsheet package, which might expect to receive files in .xlsx format.\nThe simplest file format for storing and transferring scientific data is a plain text file in ‘ascii’ (‘American Standard Code for Information Exchange’) format. This is the sort of file that can be read and produced using a simple text editor such as ‘notepad’ (on Windows) or ‘TextEdit’ (on a Mac). Commonly, such files will have an extension such as .txt or .dat.\nReading ascii files in Python is a four-step process: 1. Open the file; 2. Read each line from the file; 3. Parse each line (i.e., extract the required information from it); 4. Close the file.\n\n\n\n\n\n\nSetup Code (run this first !)\n\n\n\n\n\nWe need to make sure the data file we are going to use is saved on your computer so we first have to make a copy into the sandbox file system we are using (this area is deleted whenever we reload this page)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe can check to see if the file is available\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nReading data from a file\nTo open a file, we use the open() function, which returns a file object. It is important to assign this to a variable (here, fp) so that we can continue to access the open file.\nfilename = 'sample.dat'\nfp = open(filename, 'r')\nHere, filename is a variable holding the file name (or file path and name, if it is not in our current working directory), and the second argument, 'r', specifies that we want to open the file for reading only.\nOnce the file is open, we can read from it. There are various ways of doing this, but for small files the simplest method is generally to call the readlines() function, which returns the entire file in the form of a list:\nlines = fp.readlines()\nEach element of the list lines is now a string, containing one of the lines from the file sample.dat. Since we have read all the information in the file, we can now close the file:\nfp.close()\n\n\n\n\n\n\nExercise 1 - Read the sample.dat file\n\n\n\n\n\nOpen the file and print out the individual lines to see what it contains.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nHere is a hint that you might see in python code elsewhere. If you precede a structure like a tuple or list with a ’ * ’ then it is unpacked before being used. This might be helpful if you want to make the list of lines look more like the original file when printed. Another way would be to write a loop over all the lines and print them individually.\n\n    t = (1,2,3,4)\n    print(t)\n    print(*t)\n\n    # Output:\n    # (1, 2, 3, 4)\n    # 1 2 3 4\n\n\n    l = ['a', 'b', 'c', '...', 'z']\n    print(l)\n    print(*l)\n\n    # Output:\n    # ['a', 'b', 'c', '...', 'z']\n    # a b c ... z\n\n\n\n\n\n\npython with statement\nOpening and closing files explicitly is useful to illustrate how Python handles reading and writing files. However, doing this in practice can get quite messy because these ‘connections’ to files stay open until you explicitly close them. With single files, this can lead to data corruption and data loss, with more complex scripts you might open 10,000 files and not close any of them - you may then run into some limit on the system that will block your script or may block some other work that you are trying to do.\nPython has a really handy construct for dealing with this issue automatically and you will doubtless see code that uses ‘context managers’ aka with statements.\nThis is not a very intuitive choice of language but, once you recognise what is happening, you will be able to understand python programs more easily. Any time you have an action which needs some clearing-up to be done afterwards, the context manager handles everything behind the scenes.\nIn the case of reading/writing files, you create a ‘context’ that contains a connection to a file, which is automatically closed when the code within the context is finished. This is a bit complicated to follow, but file-management is a very clear example of how it works.\nfilename = 'sample.dat'\nwith open(filename, 'r') as fp:\n    lines = fp.readlines()\n    ...\n    ...\n\n    # fp.close() is handled automatically here\nThe with statement tells python that the file you’re giving it is only used in the following indented code, and can be closed afterwards. This performs exactly the same as manually opening and closing the file, as above, but automatically cleans up after you.\n\n\n\n\n\n\nExercise 2 - context manager\n\n\n\n\n\nCan you test to see if the fp was closed / deleted after the statement completed ? What about the contents of the file, are they available once the with statement is done ?\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nOnce you have a list of strings, you can use the list- and string-parsing tools we have already encountered to extract the necessary data and store it in appropriate data structures. The file sample.dat contains records of the mass and volume of twenty samples of a given material.\n\n\n\n\n\n\nExercise 3 - work with the data\n\n\n\n\n\nRead the data from this file, compute the density of each sample and hence the average density of the material.\n\nYou will need to parse the individual strings and store the information for your calculations.\nOutput the information to the screen with print statements so that you can validate your results.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nWriting data to a file\nWe don’t want to have to repeat this work once the processing is done, so we would like to write out the new information to a file.\nTo write data to file, we need to first open the file for writing. This can be done by using ‘w’ instead of ‘r’ when opening the file. Note that if a file already exists with the specified name, it will be immediately overwritten and lost. To avoid this, you can instead use ‘x’ when opening the file. This will throw an error if there is an existing file, rather than overwrite it. Again, when opening the file it is important to assign the result of open() to a variable, so we can write to it.\nOnce the file is open, we can write any text strings to it by calling the write() function. Remember, to insert a new line, you use the symbol '\\n', otherwise everything will be on a single line:\nfp.write(\"Hello!\\n\")\nfp.write(\"This is some text to store in a file... \")\nline = \"The file has only two lines.\"\nfp.write(line)\nOnce everything is written to the file, call close() to close it.\nfp.close()\n\n\n\n\n\n\nExercise 4 - write data to a new file\n\n\n\n\n\nCreate a new file, based on the data you read earlier. It should contain three columns: mass, sample volume and sample density. All quantities should be in SI units.\n*Remember, you can use the string-formatting tools we encountered in the last exercise to control how your numbers are written out. Verify that the file has been correctly written (e.g. Exercise 1)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nFrom the examples above, we just saw how to read and write data using Python built-in methods. These are good for simple files, but not for more complex information such as an Excel spreadsheet. Later in the course, we will encounter a number of more sophisticated tools that can help us with these kinds of files.",
    "crumbs": [
      "Basic Language Skills",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Reading and writing files</span>"
    ]
  },
  {
    "objectID": "_WIP/Test_Pyodide.html",
    "href": "_WIP/Test_Pyodide.html",
    "title": "Test Pyodide plugin",
    "section": "",
    "text": "Please enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Work in Progress",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test Pyodide plugin</span>"
    ]
  }
]